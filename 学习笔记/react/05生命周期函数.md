# 生命周期函数

## 一、初始化

![生命周期](.\函数生命周期.jpg)

```javascript
#App.js
import React form 'react'
import Child from './Child'

class App extends React.Component{
    //initialization
    //最先执行，只执行一次一定会执行
    constructor(props){
        super(props)
        this.state={
            x:0
        }
        
    }
    //mounting
    componentWillReceiveProps(){//已废弃，有性能问题和安全隐患

    }
    UNSAFE_compoonentWillMount(){
        //可以修改state
        this.state={
            y:1
        }
        console.log('UNSAFE_componentWillMount')
    }
    render(){
        return(
        <div>
            UNSAFE_componentWillReceiveProps:{this.state.y }
            app:{this.state.x}
            <Child title="Hello"></Child>
        </div>
        )
    }
    componentDidMount(){//做ajax请求时在这里进行
        //父组件render执行，子组件render一定执行。这里调用修改state,render也要调用1次
        //用setTimeout做一个测试
        this.setState({
            x:4//设置了新的数据，但页面上不更新
        })        
    }

}

export default App
```

```javascript
#Child.js
import React from 'react'
export default class Child extends React.Component{//使用PureComponent组件时，可以不用shouldComponentUpDate事件，当Props和State变化时才渲染子组件
   //updating
    UNSAFE_componentWillReceiveProps(nextProps){//父组件传给子组件的属性发生变化时触发，第一次时不触发
        console.log('componentWillReceiveProps',nextProps)
    }
    shouldComponentUpdate(nextProps,nextState){//要有一个返回值true或false,true是继续渲染，优化功能
        //根据父组件传递来的状态和属性来判断是否进行后面的渲染,nextProps,nextState
        return !(nextProps.title===this.props.title)//如果title没有变化就不需要重新渲染（不重新执行render)
        
    }
    render(){
        return(
        <div>
            Child
        </div>
        )
    }
 }

```

